Welcome everybody to the "HTTP Basics" lesson.I am doctor Svetlin Nakov from SoftUni and I will be your trainer for this lesson.I will explain the concepts of the HTTP protocol, which is the main communication protocol used in Internet to connect Web sites with Web browsers and mobile apps.In this lesson I will explain what's inside the HTTP requests, sent from the Web clients, and what's inside the HTTP responses, returned from the Web servers.We shall discuss the HTTP request methods (like GET, POST and DELETE) and what is their purpose, how HTML forms send the data from their fields through HTTP and what's inside an URL address.I will demonstrate how to monitor the HTTP traffic in your Web browser and how to compose and sent HTTP requests using specialized HTTP developer tools.

The plan for this lesson is as follows:I will start with some basic HTTP protocol concepts: the request-response model, front-end and back-end interaction, and the client-server model.I will show you some powerful tool for HTTP developers: the HTTP traffic monitoring tool in the Chrome Web browser and the Postman HTTP testing tool.I will explain how HTML forms submit data using the GET and POST methods of the HTTP request.Then, we shall focus on the HTTP requests: the request method, the request headers and the request body.I will explain in detail the HTTP responses: the response status codes, the response headers and the response body.Finally, we shall discuss the structure of the URL addresses for locating resources on the Web, which is used together with the HTTP protocol.

In case you have any question, feel free to ask in the sli.do platform using the code on the screen.The trainers will be happy to answer you quickly.

Let's start our HTTP journey with an introduction to the HTTP protocol, the request-response model, the client-server model and how it works in Internet applications over HTTP, along with the role of the Web server and the Web client, the concepts of front-end and back-end and their interaction using HTTP.

HTTP is the main Internet protocol used to communicate between Web servers (which host Web sites and server-side software components) and Web clients (such as Web browsers and mobile apps), which display the information to the users and interact with them.HTTP comes from "Hyper Text Transfer Protocol". It is a protocol originally created for transferring HTML, CSS, images and other Web resources within the global distributed information system called "World Wide Web" (or just Web).The Web consists of all Web sites in Internet, which are accessed via the HTTP protocol.Later, HTTP was extended to a general-purpose client-server protocol for the Internet and was widely used for transferring almost anything over Internet: text, images, documents, audio streaming, video streaming, chat messages and many others.Let's first explain "what is a protocol"?A communication protocol is a set of rules, which define how two or more parties are talking to each other. It defines the format of the messages exchanged and their semantics.Protocols in programming are "languages", used to communicate between machines. Like in the human languages, protocols have syntax (which specifies the structure of commands) and semantics (which specifies their meaning).HTTP is text-based client-server protocol for the Internet.Text-based means that the messages, which are exchanged, are human-readable text (not binary data, such as JPEG images).Client-server means that the communication takes place between a server (a software which stores the data and provides it upon request) and a client (a software which reads and visualizes the data from the server). We shall explain the "client-server model" in more detail a bit later.HTTP is mostly used to transfer Web resources (such as HTML files, images, styles, media and documents).For example, when you open a Web site, the Web browser connects to the Web server, hosting the requested site, and requests the URL that you have entered in the browser's location bar via the HTTP protocol. In most cases the Web server returns an HTML document that contains references to other resources, such as CSS styles, images and scripts, which are downloaded by the Web browser in subsequent HTTP requests.HTTP follows the "request-response model", which means that the HTTP client software (the Web browsers in most cases) requests resources from the HTTP servers (the Web servers) and gets these resources as a response.Clients request and servers respond to the requests: this is how it works!HTTP does not directly allow a Web sites to send data to the clients, unless this data is explicitly requested. And this is perfectly normal: users don't want a Web site to open when it is not requested. What shall happen, for example, if a spam website appears while you are working on your computer?The HTTP protocol lies on the "request-response" paradigm and cannot open a website unless someone has asked to open it.The HTTP protocol relies on unique resource locators (URLs), like "https, column, slash, slash, softuni dot org".When a resource is downloaded from the Web server, it comes with metadata (such as content-type and encoding), which helps in visualizing the resource correctly.The HTTP protocol is stateless by design, which means that it does not preserve state.Each HTTP request is independent of the others.Stateful HTTP conversations can be implemented by extra effort, using cookies, custom header fields, Web storage or other techniques.

Front-end and back-end separates the modern apps into client-side (user interface, or UI) components and server-side (data storage and processing) components. These components are in constant interaction with each other and they usually communicate via HTTP.The front-end consists of the client-side software components (the so-called "presentation layer").For example, the front-end component can be a React app, iOS mobile app or Windows desktop app. If we create an instant messaging app, for example, the front-end is where the chat heads are shown and where users read, type and send messages.The front-end implements the user interface (the UI of the software): this is what you see at the screen.In Web apps the front-end is build from HTML + CSS + JavaScript + JavaScript frameworks + some libraries.In mobile apps the front-end is built using the native mobile UI toolkit.The back-end consists of server-side components, which implement the app business logic, data storage and data processing logic and server-side APIs, exposed as services through a communication protocol like HTTP.For example, the back-end component can be a ASP.NET Core app, Java Spring app or Python Django app or other. If we create an instant messaging app, for example, the back-end is where the users, their friends, chat conversations and chat messages are stored and processed.The back-end component, which typically implements data storage and data processing, is designed to be accessed (or "consumed", like developers say) through an API (application programming interface), exposed as RESTful services or other technology, usually over HTTPIn some scenarios the back-end directly produces (or "renders", like developers say) HTML and CSS, without exposing an API. This is called a server-side Web app.In most applications the HTTP protocol connects the front-end with the back-end.The front-end requests resources using HTTP requests and the back-end sends these resources as HTTP responses.For example, an instant messaging app may use traditional HTML form at the front-end to enter the user login data, but the user authentication is performed at the back-end.Some apps use more advanced features of HTTP (like WebSockets and the Push API) to communicate instantly and bidirectionally.For example, a chat front-end app may use the WebSocket technology (over HTTP) to send and receive chat messages instantly from the back-end to the front-end.

This is an explanation about the client-server model in Web apps, where a client (the Web browser, mobile app or other) interacts with a server (the Web server, running a server-side backend components).A front-end app, running in the Web client (typically the Web browser) requests a resource from the Web server via the HTTP protocol.For example, the chat client app says: "give me the latest 10 messages exchanged between users Peter and Maria".The Web server processes the HTTP request and invokes the back-end component to produce and deliver the requested resource.This can be a static resource from the file system (such as a JPEG image), or dynamic resource (such as data coming from a database query or from an external API).In our example this might be an ASP.NET Core Web service (some code in C#), which queries the database, retirieves the requested chat messages, formats them as JSON array and returns them as HTTP response.After the backend processing is completed, the HTTP response is returned from the Web server to the Web client and is processed by the front-end app.Then, the front-end app may request (again via HTTP) some additional resources, such as some images and CSS styles.In our example, these can be the chat avatar images for the users Peter and Maria.These HTTP requests again come from the Web client to the Web server, then are handled by the back-end logic, which reads and returns static files from the local file system, then the HTTP responses are returned from the Web server to the Web client and the front-end app displays them on the screen.These sequences of HTTP requests and responses can be performed by the client app on click or in respond to other event or in a continuous loop, while the client app is active.

HTTP is an application-level protocol, which uses lower-level network protocols to transfer data from the Web client to the Web server and vice versa.When an HTTP request is sent, is it prepared as a text message, following the HTTP standard. We shall see examples a bit later.The HTTP request consists of request line + headers + body, which travel to the Web server via lower-level protocols.The data sent over a HTTP connection travels to the Web server via a TCP stream. TCP is a transport layer protocol, that connects two endpoints through a reliable, bi-directional, stream-oriented connection.It is important to mention that TCP uses port numbers to allow multiple parallel connections between two endpoints.Usually the Web server uses port 80 for plain HTTP and port 443 for HTTPS (which stands for HTTP over TLS – the transport layer security extension).The Web client uses a random unallocated source port number (for example 61850).The TCP protocol sends the stream data broken down into IP packets over the Internet using the IP protocol (the Internet Protocol).The IP protocol transfers data packets between two IP addresses in Internet.IP packets travel from the sender to the local network gateway, then to some Internet router, then to the next router, and to the next router, etc., until they reach their target network and their final IP address.When the data packets reach the destination data center, they travel between the network devices around the data center over Ethernet, PPP or other local area network protocol, until they reach the machine, operating the destination Web server.These data packets (which are called "Ethernet frames") in the Ethernet local network are transferred between two MAC addresses (or two network adapters), over LAN cables.Networking devices (such as switches, routers, hubs, repeaters, modems and bridges) communicate with each other through physical transmission media, such as LAN cables, fiber-optic cables, and electromagnetic waves in the air.Data travels between two endpoints in both directions using all these layers of networking protocols, but this complexity is hidden for the Web developers, which use only the HTTP protocol through client-side and server-side APIs.Finally, when the HTTP request is received by the Web server, it replies with an HTTP response and the response travels back to the Web client using all mentioned network layers and protocols.To use HTTP we need a URL (a unique resource address on the Web), which identifies :the Web server IP or server name (which is resolved to IP address);the port number (when we use different than the default ports 80 or 443);and the path to the resource on the Web server.We shall talk about URLs in detail a bit later.

Now, let's go into more technical detail about the HTTP protocol. I will introduce you some tools which software developers constantly use, when developing software communicating via the HTTP protocol:The network monitoring tool, built-in the modern Web browsers, which allows inspecting the HTTP trafficAnd the Postman HTTP client tool, which allows to compose and send HTTP requests and to analyze the HTTP responses

Modern Web browsers, such as Chrome and Firefox have built-in tools for network monitoring and inspecting the HTTP traffic.To show the Chrome Developer Tools, press the [F12] key in Google Chrome or right-click in a Web page and click [Inspect] in the context menu.This is how to do it: right click with the mouse and choose [Inspect].You will see the Chrome Dev Tools window, which has many tabs.From the [Elements] tab you can inspect the UI controls on the Web page (the so-called DOM tree).This is the DOM tree.From the [Console] tab you can see the errors and logs for the currently loaded Web page, and you can execute JavaScript commands.Let's type a command: console.log(new Date()). Enter.And this is the result.From the [Network] tab (which is the most interesting regarding the HTTP protocol) you can view and inspect the HTTP traffic between the currently open Web page and the Web servers to which the page communicates.Now we click a link in the Web page and the browser will load a sequence of HTTP requests.These are the HTTP requests, executed as result of this click. We have many requests in the list and we can inspect each of them.We can click on certain request to view the details about it:The HTTP request URLThe request methodThe remote server IP address and portThe request headers (such as the "Host" header, for example)The request body (which is empty for GET requests)The response status code (200 OK)The response headers (such as the "Content-Type" header)The response body (which holds the requested resource, in our case an HTML document)And we can see many other technical details…This network inspector tool is constantly used by Web developers when they want to debug a Web app and its communication with the Web server. I am sure you will love it when you start developing Web apps.

Let me show you another useful tool for developers who deal with the HTTP protocol: the Postman HTTP client.Postman is a HTTP client tool for developers. Web developers use it for composing and sending HTTP requests and analyzing the HTTP response from the server, for testing, for debugging server APIs, for researching how to use certain service API and for resolving technical issues during the software development.With Postman you can create an HTTP request, send it to the Web server, view the HTTP response, and generate a source code to execute the HTTP request in many languages, such as JavaScript, C#, Java, Python, PHP and many others.Now, lets see an example with Postman. We can send an HTTP request to retrieve the issue #1 from the "aspnetcore" project at GitHub, using the GitHub API, which is accessible via the HTTP protocol.We create a new request and name it "Get GitHub issue". An we save the request in Postman.And we choose HTTP method GET for this request.We enter the following URL for the HTTP request: https://api.github.com/repos/dotnet/aspnetcore/issues/1.And we click the [Send] button.The Web server at api.github.com responds with a long JSON object, holding a detailed information about the requested issue.We can view a code example for sending this HTTP request in JavaScript, C#, Java or other programming language.We open the [Generate Code Snippets] dialog window by clicking on the [Code] button.We select [HTTP] to see the HTTP request.We can select [JavaScript - Fetch] to see how to invoke this request from a client-side JS application, running in the Web browser.We can select also [Java] to see a sample Java code for invoking the same request from Java.You can play more with Postman during the exercise and homework sessions. I hope you will like it. I am sure you will find with ease how to install the Postman HTTP client on your computer.In case you want to explore more the HTTP client tools, I could recommend these:Insomnia Core REST Client – it is a client HTTP tool for developers, like PostmanPostwoman – it is a Web-based Postman-like HTTP client tool, running directly from the Web, without installation.Did you notice the tease in the name? It is not a "post man". It is a "post woman". You can play with it at postwoman.io.This is the tool. We can click on the [Send] button and we see the response here.

Now it's time to explain what is the relationship between the HTML forms and the HTTP protocol and how these technologies interact with each other. We shall explain and demonstrate with live examples how HTML forms submit their data to the Web server using GET and POST requests and how the submitted data is encoded as query string in the requested URL (for HTTP GET) and in the request body (for HTTP POST).

In HTML forms the "action" attribute defines where to submit the form data.If we write "form action equals to home dot html" this means that the fields inside the form will be sent to the "home dot html" script at the server-side, when the form is submitted.Most HTML forms have the "form" tag with some action URL, a set of input fields and a submit button. The submit button sends the form data to the specified URL in the "action" attribute.We can use relative or full URL.Relative URLs are evaluated relatively to the current URL, which is loaded in the Web browser. We can use slashes and the "double dot" notation to address a different folder or the parent folder of the virtual folder structure at the Web server.Full URLs are used to submit the form data to completely different Web site. For example, a Web site may embed an HTML form for newsletter subscription which submits its form fields to an external Web site, which provides email newsletter services.At the example on the screen we have two HTML pages and a form, which holds a "submit" button.When the "submit" button (which has a title "Go to homepage") is clicked, the data from the HTML form in first page will be sent to the second page "home.html" and the browser will open the second page. In our example we have no data fields, just the "submit" button.Let's see a live example how this works.We open the link from repl.it. We have two pages: index.html and home.html.Index.html is the default page at this Web site. It holds an empty HTML form with "submit" button. The action of the form is set to "home.html".Home.html is the second page, which handles the submitted form data from the first page. It just shows "Welcome Home".We click on the [Run] button to start the sample Web site.Then we open the site in a separate browser window by clicking the [Open in a new tab] button (this one with the arrow).The index.html page is now displayed in the Web browser.We click the [Go to homepage] button and the browser opens the "home.html" page by submitting the form data from the HTML form (which is empty).That's all for this example.

Now let's review another example, in which we have a form with a field.Forms can specify the HTTP method for sending the form data. It can be GET or POST.GET sends the form data as query string in the URL.And POST sends the form data in the HTTP request body.We shall see the difference in a few moments, through live examples.The first example consists of the HTML form, shown at the screen. It has the "method equals GET" attribute.This is a simple Web form, which has a text input field named "name" and a "submit" button.The form submits its data to the same page, from which the form is loaded, because it has no "action" attribute.If we run the above example, and we enter "Peter" in the text field, the form will send its data in the URL with a query string:the initial URL, followed by "question mark", followed by "name equals Peter"The form fields values are sent as sequences of "field=value" tokens after the question mark in the end of the URL, separated from each other by ampersands, and with escaping when needed. I shall explain this URL data encoding format in bigger detail later.We can test this example live at the repl.it playground.We open the link to repl.it and we wait a bit for the project to load.This sample project consists of a single HTML page.We click the green [Run] button and then open the result Web page in a new window.Now we enter "Peter" in the text field and submit the form. The form data "name=Peter" is sent to the same page through a URL query string.Now I enter "Svetlin Nakov" and submit the form. The form data is encoded as "?name=Svetlin+Nakov". The space is escaped as "+".If we enter more unusual string like "a+b=c", it will be encoded as "?name=a%2Bb%3Dc". As we can see, special characters are encoded (or escaped) using а percentage + their hex code. The space is an exception and may be encoded also as "+".

The next example consists of this HTML form on the screen. It is the same form from the previous example, but now it uses "method equals POST".It's a simple form with a text field named "name" and a "submit" button.The form submits its data to the same page, without specifying the "action" attribute.If we run the form, fill the name "Peter" in the text field and submit the form, it will send the following HTTP request:POST, the page relative URL, space, HTTP, slash 1 point 1Some headers like the content type, which says "URL-encoded form data".And the HTTP request body holds the submitted form data, which is URL-encoded as "name=Peter"Let's see the live example at repl.it.First wait for the project to load fully.And we run the example and we open it in a separate window.We enter "Peter" and we submit the form. Nothing changes in the URL. This is because the form is submitted by HTTP POST, not by HTTP GET.POST preserves the target URL unchanged and sends the form data in the request body.In contrast, GET encodes the form data in the URL as query string. This is the difference between GET and POST.Remember this difference! You may be asked to explain it at your first job interview.Now let's inspect the HTTP requests, sent by forms, using "method=post".We open the "Chrome network monitoring" tool by clicking the [F12] key. We choose the [Network] tab.We enter "Svetlin Nakov" in the form and we submit it.We can see the HTTP request, used for the form submission, in the network inspector. We click on it.We can see in the [Headers] tab the requested URL, this one.And the request method is "POST".The form data is shown at the end. Click here: [view source]. The form data is URL-encoded as "name=Svetlin+Nakov".

Now let's see an example, holding two form fields.We have an HTML form using method "POST", with two input text fields named "name" and "age" and a submit button.If we run the form and enter "Maria Smith" in the "name" field and "19" in the "age" field, the form submission will create the following HTTP request:POST, space, slash, index dot html, space, HTTP, slash, 1 point 1Some request headers follow at the next few lines, then an empty line.And the request body, which holds the submitted data.Note how the form data is encoded: "name=Maria+Smith&amp;age=19".This is the standard URL encoding used to encode the HTML form fields and URLs.This encoding can be used for text and other data fields, but it does not support file upload fields.We can overcome this limitation by switching to "multipart encoding". We shall learn about file uploading later.We can demonstrate this code live at repl.it.Wait a bit for the example to load.We open and run the example.We show the browser's network inspector.Now we type "Maria Smith" and age "19" and we submit the form.The HTTP request can be inspected in the network inspector.We can view the form data in the request and how it encodes the form fields.

It's time to explain HTTP requests, their request methods, headers and body content in more detail.Remember that the HTTP protocol operates on the "request-response" model. The Web client sends HTTP requests to the Web server, and the Web server replies with an HTTP response. The request and the response messages follow a certain text-based format, which we will discuss in detail.

HTTP defines methods to indicate the desired action to be performed on the identified resource. The most often used HTTP methods are GET, POST, PUT, DELETE and PATCH.The GET method retrieves a specified resource. It is used to download a Web page, CSS file, script, document or other resource from a Web site.For example, if you open your favourite news site, its content will be downloaded using HTTP GET requests.GET can retrieve a list of resources (for example all the news from the front page of a news Web site) or get a single resource (for example, a single news article).The POST method is used to create (or store) a resource at the Web server.Remember that POST creates something new at the Web server. It modifies the state at the server-side.For example, when you login with your username + password at a Web site, the login form uses a POST request to send your credentials to the server and if the login data is valid, the server creates a new session and sends the session identifier as a cookie. We shall learn about "cookies" later, when we study Web programming.Another example of HTTP POST is when you enter and submit your shipping address in an e-commerce application.PUT is used to update (or replace) an existing resource. The HTTP PUT method is used in some applications to replace an existing resource with a new version of this resource.For example, HTTP PUT can be used to change the shipping address in an e-commerce application.DELETE is used to delete (or remove) an existing resource.An example of HTTP DELETE request is for deleting an item from the shopping cart in an e-commerce Web application.The PATCH method updates an existing resource partially. It is used to modify a field of given object.An example of HTTP PATCH request is for updating the quantity of an order item in the shopping cart in an e-commerce Web application.The HTTP HEAD method retrieves the resource's headers, without the resource itself.HEAD is used rarely, for example to check for modifications at the server side.The four most important operations for most applications are GET, POST, PUT and DELETE, the so-called "CRUD operations".CRUD is an abbreviation from "create, read, update, delete" and is usually implemented by apps and APIs, which manage persistent data.Most applications support at least these four CRUD operations for the objects they store, edit and manage.For example, if you have a phonebook app, you will need at least the following basic operations: view all the entries from the phonebook, view certain phonebook entry, add a new phonebook entry, modify existing phonebook entry and delete a phonebook entry. These are essentially the classical CRUD operations.HTTP support a few more methods, which are used rarely, in special situations:CONNECT is used to open a two-way socket connection to the remote Web server. A socket connection can overcome the limitations of the HTTP protocol and its request-response model through lower-level communication.The OPTIONS method is used to describe the communication options for specified resource. For example, in some situations, the Web client asks the Web server using an HTTP OPTIONS request if it is allowed from a security perspective to request a certain resource. This is called a "cross-origin request" or "CORS".The HTTP TRACE method is designed for diagnostic purposes during the development and is used very rarely.

Now let's give a full example of an HTTP request. HTTP requests consist of request line, request headers and request body.The request starts with the "HTTP request line". This is the command we send to the server. This line says what resource we want to get or process.The request line starts with the request method (in our example "GET"),followed by the request-URI (this is the resource path, relative to the server's root),followed by the HTTP version string (for example "HTTP/1.1"),followed by a new line (CR + LF).In most computer systems the new line consists of two characters: CR (carriage return, the ASCII code 13) and LF (line feed, the ASCII code 10). This is the new line format used in the HTTP protocol.Web browsers use URLs, but HTTP uses URIs to address the resources. What's the difference?URL stands for "uniform resource locator" and it describes a full unique address for a resource in Internet, which consists of protocol + host + resource path, for example: https://softuni.org/about. The URL is what we type in the browser's location bar.URI stands for "uniform resource identifier" and it holds a full or relative unique path to a resource, for example "/about".When we request a resource over HTTP, we specify the relative URI of the resource in the request line and we specify the host name in the request headers. Both relative URI and host name come from the URL we want to access.At the next few lines, the HTTP request headers are given. Headers specify specific parameters about the requested resource:An important header is the "Host" header, holding the requested resource. If we have several Web sites at the same Web server (for example softuni.org and learn.softuni.org), this "Host" header will tell the server which web site to access.The other headers specify settings like what kind of content the client can accept and understands (for example only HTML or any content), what is the preferred language (such as English or Russian) that the client wants to use, what kind of compression the client understands (for example gzip and deflate), what are the client Web browser's brand and version (encoded as the so-called "user agent" identifier) and other parameters.The headers section in the HTTP request ends by an empty line (CR + LF twice).After the request headers, the request body comes.It can hold anything, for example URL-encoded data or JSON object or binary data.The request body can also be empty, which is typical for the HTTP GET requests.

Let's perform a live example with Postman. We want to open the URL:https://api.github.com/repos/dotnet/aspnetcore/issues/1We open the "Postman REST Client" app.We create a new GET request and we enter the URL we want to retrieve.And then we click the [Send] button.Postman executes the HTTP request and visualizes the HTTP response from the Web server. It is a JSON object describing the retrieved GitHub issue. 

Now let's review another example: a sample HTTP POST request.We want to create a new issue at GitHub using HTTP POST.But the GitHub API requires authentication to make changes, and this is complicated.Instead of using the GitHub API, we shall send a similar request to the Postman Echo Service, which is a free service, designed for testing purposes. It simply returns the data posted to it.The URL for the Postman Echo Service for HTTP POST is the following:https://postman-echo.com/post Our sample HTTP POST request holds a request line + headers + body.The HTTP request line holds the method "POST" + the relative request-URI "/post" + "HTTP/1.1" (the protocol version).The headers specify the host (which comes from the URL), in our case postman-echo.com, also the content type, which is "application/json", and a few other settings, like the size of the HTTP body in bytes (the "content length" header).The request body holds a JSON object, which describes the new GitHub issue (in a simplified form).

We can send the POST request from the previous slide using the Postman HTTP client tool:We open Postman and create a new request.We select a method "POST" from the drop-down and we put the URL https://postman-echo.com/post.We put the JSON code from the previous slide in the "request body" tab and we send the request.The response from the HTTP server is displayed below. It is a JSON object, which holds information about the request.

It's time to explain the HTTP responses, their response status lines, headers and body content in more detail.Again, I recall that the HTTP protocol operates on the "request-response" model. The Web client sends HTTP requests to the Web server, and the Web server replies with an HTTP response. The request and the response messages follow a certain text-based format. Let's review what's inside the HTTP responses.

Let's start with a sample HTTP response. It consists of 3 parts:Response status lineResponse headersAnd response bodyThe HTTP response status line starts with the protocol version, followed by the response status code, followed by a human-readable text explanation of the status code.The status code tells the client whether the requested operation was successful or not. It may report success (with status code 200) or error (with status code 400 or 500).There are many status codes, specified in the HTTP standard, and we shall discuss them in detail later.After the HTTP status line the HTTP response headers come.Response headers provide metadata about the returned resource (or the returned error), such as content encoding, content size in bytes, content last-modify date and many others.After the response headers and the empty line separator, the HTTP response body comes.This is the requested resource, the returned content.It can be a text or a binary data or can be empty.In our example the Web server returns an HTML page.

Let's discuss in more detail the HTTP response status codes.HTTP status codes are 3-digit integer numbers. The first digit serves for grouping the status codes.Status codes starting with 2 indicate a successful operation.The most used HTTP response status code is "200 OK", which means that the requested resource has been successfully retrieved and returned. This is what the server returns when you open a news article successfully.Status "201 Created" means that a new resource has been created successfully, for example, a new user is registered.Status "204 No content" means that the request was successful, but there is nothing to return, for example, the message was sent successfully to a specific user.Status codes starting with 3 are used for redirection to another URL.Status code "301 Moved Permanently" is used to permanent redirection to another URL. For example, when a Web site changes it domain name, the old domain name is permanently redirected to the new domain using a "301 permanent redirect".The status code "302 Found" is used to temporarily redirect to another URL. For example, the "/hot-offer" location on a website may be redirected to a different offer each week.Status code "304 Not Modified" is returned after a conditional HTTP GET, which says "I have this resource from yesterday. Please return it only if you have a newer version". This is a mechanism used by Web sites and Web browser for caching images and multimedia content that rarely change. The response from a conditional HTTP GET is "304 Not Modified" (no newer version) or "200 OK" (a newer version is found).Status codes starting with 4 indicate a client error, such as "bad request" or "not found"."400 Bad Request" means that the client has sent an invalid request. For example, to view a news article, the article ID should be specified. If the browser requests a news article without specifying an ID, the Web server should return "400 Bad Request".Status code "401 Unauthorized" is returned when the resource is available but can be accessed after authentication only. For example, a Web site could serve specific content to its registered users, after successful login.Status code "403 Forbidden" is returned when the resource is restricted for the current user. For example, the admin interface in many Web sites is available for users with role "Administrator" and for the other users the access is "403 Forbidden".Status code "404 Not Found" means that the requested resource is missing. This can happen when users type incorrect resource URI or after an existing resource is deleted from the server. The "Not Found" status code is used very often, and experienced Internet users know it very well.The status code "409 Conflict" is returned when the requested operation cannot be performed due to conflict. For example, when a new user is registered, if the specified username or email is already taken, the server may return "409 Conflict".Status codes starting with 5 indicate a server error, such as "service unavailable".The status code "500 Internal Server Error" means that the server crashed while processing your request.This is the most common server-side error message in the world of software development."500 Internal Server Error" is caused either by a bug of the software at the server side, or by an incorrect invocation made by the client.For example, if the client requests a user to be deleted, but this user has pending orders, the server may not be able to delete the user and may return "500 Internal Server Error"."501 Not Implemented" may be returned when certain functionality is not yet implemented by the server-side software."503 Service Unavailable" may be returned when a component at the server side is not ready, for example if the database server is down.There are tens of HTTP response status codes, but the most important are the ones that I explained briefly here. You can learn about the other status codes in the official HTTP 1.1 standard: the RFC 7231.

Many HTTP headers play an important role in modern Web development. Now I want to focus on the "Content-Type" and the "Content-Disposition" headers.The "Content-Type" and the "Content-Disposition" headers specify how to process the data in the HTTP request or in the HTTP response body. These headers can be used both in the HTTP requests and in the HTTP responses.For example, the header "Content-Type: application/json" specifies a JSON-encoded data (a JSON object). By default, the UTF-8 encoding is used.The "Content-Type: text/html; charset=utf-8" specifies an HTML document with UTF-8 encoding. Note that the encoding (or the charset) specified in the HTTP headers has a higher priority than the encoding specified in the header of the HTML document (using the "meta charset" HTML tag).The next example combines the "Content-Type" and the "Content-Disposition" headers in the HTTP response to inform the Web browser that the returned resource is a PDF document, which has a file name "Financial-Report-2020.pdf" and should be downloaded as attachment (not open directly in the Web browser, but saved as an external file).Most Web browsers will process the response from this example by downloading the file in the [Downloads] folder on the client device.In the HTTP requests the "Content-Type" header specifies what kind of data the client sends to the server, for example a JSON document or URL-encoded form data or a plain-text document or a JPEG image.When the data is text-based, the "charset" encoding can also be specified (for example UTF-8 or windows-1251) and this is highly recommended, because wrong encoding may result in broken and unreadable text stored in the database.The value of the "Content-Type" is a media type identifier like "text/html", "application/json", "image/jpeg" and many others.The list of officially standardized media types and their officially assigned media type identifiers are maintained by the Internet organization IANA at https://iana.org/assignments/media-types.In the HTTP responses the "Content-Type" header specifies what kind of data the server returns to the client, for example an HTML document or a JPEG image.When the data is text-based (like HTML or text document), the "charset" can also be specified (for example UTF-8 or windows-1251). Specifying explicitly the character encoding is highly recommended and help visualizing correctly the returned document.When Web browsers open a Web site, by default it uses the character encoding from the "Content-Type" response header.

This is an example of small HTTP conversation, which consists of HTTP request, followed by an HTTP response.The HTTP request used the GET method to download the resource at URL https://softuni.org/trainings/courses.The relative request URI is "/trainings/courses".The host comes from the URL and it is "softuni.org".The user agent (which is the Web browser identifier) is et to be "Mozilla/5.0"No other headers are sent. These are enough and the HTTP request is properly composed.The HTTP response form the Web server returns:Status code "200 OK", which means that the requested resource is found and will be returned in the response body.The "Date" header shows the date and time at the Web server at the time when the HTTP response is created.The "Server" header shows information about the server software used to process the HTTP request (the Web server). This is the Microsoft's Web server, used by the ASP.NET app behind the Web site sofuni.org.The "Last-Modified" header indicates the last modification date and time of the returned resource.The header "Content-Length" indicates the size of the returned resource (in bytes). Using this value, the Web browser could visualize a download progress bar (with increasing percentages over the time) for large files or documents.After the headers, an empty line comes and then the requested resource is returned in the HTTP response body.This small example illustrated what happens when an Internet user opens a Web site. The browser executes a sequence of steps:From the URL, the Web server's IP address is extracted, and the browser establishes a TCP socket connection with the Web server. If HTTPS is used, a TLS security layer is initialized, and an encrypted channel is established.Using the connection with the Web server, the browser sends a sequence of HTTP requests and visualizes the HTTP responses from the Web server.Usually, the first downloaded resource is the HTML document, corresponding to the site's URL.The returned HTML document is processed by the browser, and all styles, scripts, images and other referenced resources are extracted. For each referenced resource, a separate HTTP request is sent to the Web server over the already established connection.When the resources are loaded, the HTML document is rendered, using these resources (scripts, styles and images) and the user can see and use the Web site.A typical business Web site today makes 50-100 HTTP requests to load and display its front page. You can see these requests by using the Chrome network monitoring tool or other HTTP traffic analyzer tool.

Web browsers and other apps use URL addresses to access Web sites and server-side resources from the Web.Now it's time to explain in greater detail the structure of URL addresses and their parts: the protocol identifier, the host name or IP address, the optional port number, the resource path, the query string and others.Uniform Resource Locator (URL) is an essential part of the World Wide Web technology, and developers need to know very well their structure and functionality. Let's learn more about URLs.

Uniform Resource Locator (URL) identifiers are unique addresses in Internet, used to identify resources, Web sites and documents on the Web.The URL is what we type in the browser address bar, for example: https://softuni.org.The URL string contains the hostname and path to the resource, and sometimes it can include more elements like port and query string.The URL address has the following form (like it is shown on the slide):http://mysite.com:8080/demo/index.php?id=27&amp;lang=en#lecturesIn this example the URL uses the "http" protocol, the host name is "mysite.com", the connection port is 8080, the resource path is "/demo/index.php", the query string is "?id=27&amp;lang=en" and the fragment is "#lectures".These are the parts of the URL. Let's discuss them in detail.The network protocol is the protocol used to talk to the server.It can be http, https, ftp, sftp, rtmp, rtmps or other. All these are protocols used to access remote resources, such as files, documents and streaming media.Modern Web sites use https (which is HTTP over a secure channel).Older Web sites use plain http.The next part of the URL is the host.Some examples are: softuni.org (simple domain name), mail.google.com, static.xx.fbcdn.net (subdomain), 127.0.0.1 (IP address), web (hostname in the local network), ::1 (IPv6 address).The host is the server name or IP address, which runs the server software, used to access the specified resource, typically the Web server.The host together with the port define the endpoint for establishing the connection with the server.The next part in the URL is the port number.If not specified, the default port for the http protocol is 80 and for the https protocol is 443.The port number is an integer number in the range [0…65535].The port comes from the underlying TCP protocol, which operates using port numbers.The next part of the URL is the path.Here are some examples are: /, /forum, /gallery/index.php, /admin/modules/forum/styles/forum.cssThis is the path to the requested resource, relative to the server root.If we request a file from the Web server, this will be the full path to the file, relative to the server root folder.The query string is optional part of the URL, which follows after the path.Example of query string is given on the slide: ?id=27&amp;lang=en.The query string holds parameters passed in the URL. It is separated from the path by the "questionmark" symbol.Each parameter has the form name=value. Parameters are separated from each other by the "ampersand" symbol.The fragment part is the last optional part in the URL. It follows after the "hash" symbol.For example, the URL can end by "#slides", which instructs the Web browser to navigate to the section "slides" in the loaded document.A rarely used URL format can also include authentication data, sent through the "Authorization" HTTP header.Example of such URL is: http://username:password@example.com/

The query string in the URL contains data that is not part of the path structure.For example, let's take this URL:http://example.com/path/to/page?name=tom&amp;color=purpleThe query string in this URL is:?name=tom&amp;color=purpleThe query string is commonly used in searches and dynamic pages.For example: https://nakov.com/?s=bookThe query string is the part of the URL after the question mark (?) symbol and it is optional. Most URLs don't have query string.Parameters in the query string have the "name=value" format. Names and values, which hold special characters are URL-encoded. Example: https://nakov.com/?s=Svetlin%20Nakov. We shall learn about the URL encoding later.Multiple parameters are separated by the &amp; delimiter, like it is shown at the above example, where the query string is ?name=tom&amp;color=purple. This query string holds two pairs of parameters:name=tomcolor=purple

Sometimes the query string parameters need to hold special characters like the "=" symbol or the "?" symbol. To maintain this, the query string need character escaping, which means that some special characters are replaced by sequences of other characters. This is called "URL encoding".URLs are encoded according to RFC 1738 standard, which describes the Uniform Resource Locators (or URLs).Normal URL characters (such as digits and Latin letters) have no special meaning in the URLs and are not encoded.Reserved URL characters – have a special meaning in the URLs and are encoded, in order to be part of the URL without breaking it.The reserved characters are the most punctuation marks and many others. Some of them are shown on the slide.Reserved characters are escaped (or URL encoded) by using the so called "percent encoding", which uses the "%" symbol plus the hex code of the character (in its UTF-8 representation). Example of reserved character is the character "?", which is encoded as "%3F".The space is also a reserved character in the URLs and it can be encoded in two different forms: as "+" or "%20".

Most non-letter and non-digit characters are escaped in the "% hex code" format.Examples are given below:The space is encoded as %20.The quote is encoded as %22.The hash is encoded as %23.The dollar is encoded as %24.More examples:The percentage is encoded as %25.The ampersand is encoded as %26.The Cyrillic letter "sht" is encoded as %D1%89. It consists of 2 hex codes in the UTF-8 charset.The Chinese letter "Ài" (love in Chinese) is encoded as %E7%88%B1.A more interesting example is shown at the slide. It combines Cyrillic letters, Chinese letters and Latin letters, which after URL encoding take the form shown on the screen. During the URL encoding each non-standard char is converted to its corresponding UTF-8 bytes, represented as hex digits with the percentage as prefix.

Following the concept of URL-encoding, some valid and invalid URLs are shown as examples.At the screen we can see some valid URLs.And now we can see some invalid URLs.At the first example, the space should be encoded as "+" or "%20".At the second example the Cyrillic letters should be encoded as %D0%BA%D0%BE%D0%B4.

This was the lesson about the HTTP protocol. Let's summarize what we learned from this lesson.HTTP is an abbreviation from "Hyper Text Transfer Protocol".HTTP is a text-based client-server protocol for the Internet, used by millions of Web developer.HTTP works with message pairs: request and response.The HTTP request consists of method + headers + body.The method can be GET, POST or other.The request headers specify some additional instructions about the request like the content type of the data sent with the request.The request body holds the payload of the request, for example the submitted HTML form data.The HTTP response consists of status code + headers + body.The status code indicates a success or error. "200 OK" means success. "500 Internal Server Error" means error.The response headers specify some additional instructions about the response like the content type and character encoding of the data sent with the response.The response body holds the payload of the response, for example an HTML document.The URL addresses consist of several parts: protocol, host, port, path, query string and fragment. Some of them are mandatory, some are optional. Most URLs consist of protocol + host + resource path, for example: https://softuni.org. The query string is the part after the "?" symbol. It is optional. It holds a sequence of name-value pairs, URL encoded.

If you have any questions, please feel free to ask.